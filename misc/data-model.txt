## Description
This file documents how we're storing data in a networkx.Graph object representing
the topology of an AWS VPC

----

vpcs = boto3.ec2.resource.vpcs iterable -- from .all() method

sec_groups = boto3.ec2.resource.security_groups iterable -- from .all() method

networks:= python dict
 <vpc-id>: networkx.Graph

---

sec_group_rule_dict:= dict of rules for each sec_group
  {
    <security_group.id>: {
          inacl: <formatted ace string>,  << taken from ec2.SecurityGroup.ip_permissions
          outacl: <formatted ace string> << taken from ec2.SecurityGroup.ip_permissions_egress
          },
    ...
  }

^^ the above should change to structure below - which is data, rather than formatted strings
sec_group_rule_dict = {
  'sec_group_id': <sgid>,
  'inacl': [
    {
      'vpcid': <vpcid>,
      'subnetid': <subnetid>,
      'sec_grp_id': <sgid>,
      'direction': 'in'|'out',
      'sources': [<s1>, <s2>, ...], << sources can be security group ID's or CIDR ranges
      'proto': <protoname>, << string = tcp, upd, icmp, all,
      'port_range': (<start>,<end>)  < start, end are the starting and ending port numbers - can be the same
    },
  'outacl': [
    {
      'vpcid': <vpcid>,
      'subnetid': <subnetid>,
      'sec_grp_id': <sgid>,
      'direction': 'in'|'out',
      'sources': [<s1>, <s2>, ...], << sources can be security group ID's or CIDR ranges
      'proto': <protoname>, << string = tcp, upd, icmp, all,
      'port_range': (<start>,<end>)  < start, end are the starting and ending port numbers - can be the same
    }
  ]
}

---

networkx.Graph:
  graph: (dict) << this is effectively a dict holding arbitrary data, using it here to store VPC information
    vpc: <vpc-id>
    cidr: <aws cidr assoc w/VPC>
    isdefault: <aws flag indicating this is the default vpc in the account>
    state: <string indicating the state of the aws VPC> << not sure of possible values
    main_route_table: <rtbid>
    nacls (dict):
      id (dict):
        name (string): taken from NetworkAcl.tags
        default (boolean): True if this is the default NACL for this VPC
        assoc_subnets (list): list of subnet ID's to which this NACL applies
        ingress|egress_entries (list): each entry is a dict, one list for ingress rules and one for egress
          number (int): rule # (determines order?)
          action (string): allow|deny
          protocol (string): name of protocol, e.g. tcp, udp, icmp, all
          ipv4_block (string): source or dest range in CIDR notation, depending on direction of rule
          ports (tuple): 2tuple of the form (start, end), where the port range is start-end (end=start if one port)





  node: (dict) << dict of nodes, top level keys are the network nodes, e.g. subnets, vpngws, etc

    <route_table_id> (string: 'rtb-...')  << this is a route table - which I'm adding as a node in the network - i.e. a router
      name (string): name of the route route table from tags, or None
      main: None|<vpc-id>  << uuseful for finding subnets that are implicitly associated w/the main route table
      assoc_subnets: [snid1, ..., snidn]  (may be empty)
      routes: [<route_data_dict>, ...]
        route_data_dict:
          dest_cidr:
          dest_pfx: << prefix list, likely only used when NH is a VPC endpoint
          gw_id: name/id of the gateway << can be one of sevaral types: igw, vgw, pcx, natgw, instance-if (when a nat instance)
          nat_gw:
          egress_gw: << if an egress ONLY gw
          nat_instance (string): ID of nat instance as next hop (given by Route.instance_id)
          state (string): active|blackhole|??? , not sure of other possibilites
          origin: 'CreateRouteTable'|'CreateRoute'|'enableVgwRoutePropogation'

    <subnet.id>:  << nodes are any hashable object, I'm using the string from the boto3 object property subnet.id
      name (string): name of the subnet, if there is one, otherwise use the subnet ID
      avail_zone: boto3.ec2.subnet.availability_zone
      default (boolean): True of this is the default subnet for the associated Availability Zone
      cidr: ...cidr_block
      assign_publics: ...map_public_ip_on_launch
      state: ...state
      'sec_groups': set(<sec_group_id>,...)  << this is pythong set of unique security groups "attached" to the subnet (via the instances on the subnet)
      inacl|outacl (list):  list of dicts representing rules, one dict per rule
        {
          sgid (string): security group ID, redundant but neecessary for lookups
          proto (string): all|tcp|ucp|???
          src_dst (list): list of strings representing CIDR blocks, security groups, ???, for inacl these will be sources, four out acl's they will be destinations
          ports (tuple): 2-tuple representing the destination port range (dest for both in and out acl's).  a single port is represented by a 2tuple with the same value in both slots
        }

      assoc_route_table: None | <rtb-id> << route table ID of the route table to which this subnet is associated  NB: all subnets are associated with one and only one rtb, but those assocaited w/the "main" rtb in a given vpc are not listed in rtb.associations - i.e. you have to find these by subtracting the set of subnets assocaited with route tables from the list of all subnets :(

      sec_groups: python set of boto3.ec2.SecurityGroup.id
      nacl (string): id of the NACL assocaited with this subnet, or None

    <vpngatewayid>: (dict)
      name (string): name of this gateway (from tags with Key = Name)
      state (string): 'pending'|'available'|'deleting'|'deleted'
      avail_zone (string): AWS AZ in which this vgw resides (AvailabilityZone)
      vpc_attachments (dict): (VpcAttachments)
        vpc_id (string): id of an "attached" vpc (VpcId)
        state (string): attaching|attached|detaching|detached (State)



    <natgwid>: (dict)
      state: pending| failed|available|deleting|deleted
      

    <internet_gw_id>: (string)

    <peer_conn_requester/accepter_id> (string): (dict)
      accepter_vpc_id (string): vpc ID of the accepting VPC
      requester_vpc_id (string): vpc ID of the requesting VPC
      status: (dict)
        Code (string): status code - e.g. peering_connection.status['Code']: pending-acceptance | failed | expired | provisioning | active | deleted | rejected 
        Message (string): related message, e.g. pcx.status['Message'] 

    <vpce (endpoint) ID vpce_xxxx> (dict):
      # add vpcid - would be redundant but easire to use when iterating over vpce's
      service_name (string): AWS service to which this VPCE connects (only S3 for now)
      state (string): one of: Pending|Available|Deleting|Deleted
      route_table_ids (list):  list of route table ID's that, I assume, are using this as a NH for one or more routes  << this is possibly not needed for our puroposes here but might as well take it?
        rtb_id (string)


  edge: (dict) (also known as adj)
    <route_table_id>: (dict) of adjacent nodes, built using route tables
      <adj_node>: (dict) attributes; the adjacent node would be one of the existing nodes above, e.g. peering connection, subnet, etc.

reformatted rules: << list of rules, ea rule is dict containing sec_group_id, sources, proto and port
  [
    {
      'sgid': <security group id>,
      'source': ['<uid>:<grpid>:<grpname>', ...],  << i.e. this is a list of strings w/subformat that includes 3 bits of data uid, security grp id and sec group name; i believe the uid = the uid of the account owner
      'proto': <ip proto> << one of tcp, udp, icmp or all
      'ports': (<startport>, <endport>)  << string representation of the tupel (start, end)
    },
    ...
  ]

---

# protocol number:name map  # dict loaded from YAML file
proto_num (int): proto_name (string)

---

# check thresholds  # dict loaded from YAML file
check_name (string): threshold_value (int)

---

# risky ports # dict loaded from YAML file
app_proto_name (string):
  transport_proto (string):  # basically TCP or UDP
  ports (string): # list of ports for that L4 protocol
    port (int)  # list of ports

example YAML contents
'ssh':
  'tcp':
  'ports':
    - 22
'rdp':
  'tcp':
    - 3389
'Trinoo':
  'udp':
    - 27444
    - 31335

---

# allowed protocols  #  list loaded from YAML file
l3_protocol_number (int)  # this is the only thing in the file, one entry per allowed protocol, per line

example YAML content
- 6 # TCP
- 17 # UDP
- 1 # ICMP

